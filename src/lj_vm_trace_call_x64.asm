;;; Calling trace machine code.
;;; Copyright (C) 2019 Max Rottenkolber. See Copyright Notice in luajit.h

global lj_vm_trace_call
global lj_vm_exit_interp

section .data

section .text

;;; Execute the machine code sequence of a trace. Accepts pointers to a
;;; TraceCallState (see lj_vm.h) and the machine code as its arguments.
;;;
;;; Code generated by the JIT is rather deeply integrated into the former
;;; structure of the assembly bytecode VM. I.e., it expects certain former VM
;;; registers to preserve across interpreter/trace boundaries.
;;;
;;; Traced machine code does not honor the System V Calling Convention, we have
;;; to save and restore callee-save registers before entering trace machine
;;; code.
;;;
;;; We setup the the former DISPATCH and BASE registers with values from
;;; our TraceCallState (tcs) before calling the JITed code. We also push tcs
;;; to the stack for use by trace exit handlers.
;;;
;;; The JITed code does not actually return by itself. At its end it will call
;;; a trace exit handler (our chance to copy back the execution's results into
;;; tcs) which will in turn return to lj_vm_trace_call.
;;;
lj_vm_trace_call:
;;; Save callee-save registers.
        push rbx
        push rbp
        push r12
        push r13
        push r14
        push r15

;;; Setup register state (DISPATCH, BASE) for use by JITed code from tcs.
        mov r14, [rdi+0]        ;tcs->dispatch
        mov rdx, [rdi+8]        ;tcs->base

;;; Save tcs for exit handler.
        push rdi

;;; Call JITed code, which will jump to exit handler which in turn will
;;; return here.
        call rsi                ;mcode

;;; Pop tcs.
        pop rdi

;;; Restore callee-save registers.
        pop r15
        pop r14
        pop r13
        pop r12
        pop rbp
        pop rbx

;;; Return to interpreter.
        ret


;;; Exit handler for JITed machine code.
;;;
;;; Here we copy the PC, BASE, and RD/MULTRES register state at the end of the
;;; trace back into our stowed away TraceCallState (tcs) to be consumed by our
;;; bytecode interpreter.
;;;
lj_vm_exit_interp:
;;; Restore tcs.
        mov rdi, [rsp+8]

;;; Save trace exit state to tcs.
        mov [rdi+24], rbx       ; tcs->pc = PC
        mov [rdi+8], rdx        ; tcs->base = BASE
        mov [rdi+16], eax       ; tcs->multres = RD/MULTRES

;;; Return to lj_vm_trace_call.
        ret
